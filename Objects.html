<script type="text/javascript">
	
	//Like JSON file
	var ourCat = {

		"name": "Billi",
		"legs": 4,
		"friends": ["everyone"]
	}

	console.log(ourCat.friends[0]);
	console.log(ourCat["friends"]);
	

	//Updating
	ourCat.friends = "No One";
	console.log(ourCat.friends);

    //Deleting
    delete ourCat.friends;
    console.log(ourCat);

    //We can use objects, instead of switch statement

    function checkObj( checkProp){
    	 if( ourCat.hasOwnProperty(checkProp)){
    	 	return ourCat[checkProp];
    	 }else{
    	 	return "Not found";
    	 }
    }

    console.log( checkObj("name"));

//Nested Object
    var myStorage = {
    	"car": {

    		"inside":{
    			"gold":"Gloves"
    		}
    	}
    }

console.log( myStorage.car.inside.gold);

var collection = {

	1: {
		"artist": "sunny",
		"tracks": [1999]
	},

	2:{
		"tracks":[]
	},

	3:{
			"album": "Gold"
	}
}

function updateRecords( id, prop, value){
	if( value === ""){
		delete collection[id][prop];
	}else if( prop === "tracks"){
		collection[id][prop] = collection[id][prop] || []; //This is like else statement
		collection[id][prop].push(value)
	}else{
		collection[id][prop] = value;
	}

	return collection;
}

console.log( updateRecords(3, "tracks",1999));

var myArr = [];
var i = 0;
do{

		myArr.push(i);
		i++;
}while(i<5)

console.log(i, myArr);

var randomNumber0and19 = Math.floor( Math.random() * 20);

console.log( randomNumber0and19);

//Converting in to Integer
var str = "56";
console.log(parseInt(str));

function checkEqual(a, b){

	return a === b ? "equal":"not equal";
}

console.log(checkEqual(2,2));

function checkSign(num){
	return num>0 ? "positive" : num<0 ? "negative":"zero";
}

console.log( checkSign( 10 ));

//We can't declare like that, if we use let keyword
// let catName = "Quincy";
// let catName = "no";

// console.log(catName)

function checkScope(){
	"use strict";
	let i = "function scope";

	if( true){
		let i = " block scopee ";
		var j = "block scope";
		console.log(i);
	}
	console.log(i);
	console.log(j);
}

checkScope();

//We can't reassign the value, but const has all the features of let keyword.
const CHECK = 5;

const arr = [2,3,4];


function arrValue(){
	// "use strict"
	// arr = [4]
	arr[0] = 9;
}

arrValue();
console.log(arr)

//Really Freezing the object.
Object.freeze(arr)
arrValue();
console.log(arr)

//Different ways to write the function
var myConcat = function(arr1, arr2){
	return arr1.concat(arr2);
}

console.log( myConcat([1,2], [3,4,5]));

//Another way to write the function.
var myConcat2 = (arr1, arr2) => arr1.concat(arr2);

console.log( myConcat([1,2], [3,4,5]));

//Nested Functions
 const arrayNum = [4,5.6,-9.8,6,-2];
 const squareList = (arr) => {
 	const squaredInt = arr.filter(num => Number.isInteger(num) && num>0).map( x => x*x);
 	return squaredInt;
 }

 console.log(squareList( arrayNum));

//Setting automatic value
 const increment = ( function(){
 	return function increment(number, value = 1){
 		return number+value;
 	};
 })();
 console.log( increment(5,2));
 console.log( increment(5));

//Alterantive way to add numbers
const sum = (function(){
	return function sum(...args){
		return args.reduce( (a,b) => a+b,0)
	}
})();

console.log(sum(1,2,3,4));

//Copying Array
let arr1 = [1,2,3];
let arr2;

arr2 = [...arr1];
arr1[0] = 'changed'
//But with the reference like arr2 = arr1, the value of arr2 would be also changed.		
console.log( arr2 );

//Assigning values from object
var voxel = {x:3, y:4, z:5};
var x = voxel.x;
var y = voxel.y;
var z = voxel.z;

const{ x: a, y:b, z:c} = voxel;

//Nested
const forecast = {
	'today':{min:3},
	tomorrow :{min:4}
}

const { tomorrow : {min : minTommorow }} = forecast;
console.log( minTommorow )

//Assigning from array
const [z1,x1, , ,y1] = [1,2,3,4,5,6];
console.log( z1,x1,y1 )

//Creating a copy of array
const source = [1,2,3,4,5];
function removeFirstTwo(list){

	const [, , ...arr] = list;
	return arr;
}

console.log( removeFirstTwo(source));

//Only accessing certain property of the object
const stats = {
	max: 55,
	min: 20
}
const half = (function() {
	return function half( {min, max}){
		return (max+min)/2;
	};
})();

console.log( stats);
console.log( half(stats));

//Backtac,we can write multiline strings, and also put variables inside the string
const result = `Hello ${stats.min}
						Hi`;
console.log(result)	

//Accessing attributes of object

var resultSource = {
	success: ["max", "min", "sum"]
}	

function makeList(arrCheck){

	var finalResult = [];
	 for( let i = 0; i<arrCheck.length; i++){
	 	finalResult.push(`<li class="text-warning">${arr[i]}</li>`);
	 }
	 return finalResult;

 
}

console.log(makeList(resultSource.success))
</script>